// Generated by CoffeeScript 1.10.0
(function() {
  var SearchPath, fs, path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  path = require('path');

  fs = require('fs');

  SearchPath = (function(superClass) {
    extend(SearchPath, superClass);

    function SearchPath(opts1) {
      var base, base1, ref;
      this.opts = opts1 != null ? opts1 : {};
      if ((base = this.opts).basedir == null) {
        base.basedir = process.cwd();
      }
      if ((base1 = this.opts).encoding == null) {
        base1.encoding = 'utf-8';
      }
      this.opts.exts = (ref = []).concat.apply(ref, this.opts.exts);
      SearchPath.__super__.constructor.apply(this, arguments);
    }

    SearchPath.prototype.exists = function() {
      var i, k, opts, paths, ref, ref1, v;
      paths = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), opts = arguments[i++];
      if (opts == null) {
        opts = {};
      }
      if (!(opts instanceof Object)) {
        paths.push(opts);
        opts = {};
      }
      ref = this.opts;
      for (k in ref) {
        v = ref[k];
        if (opts[k] == null) {
          opts[k] = v;
        }
      }
      return (ref1 = []).concat.apply(ref1, paths).filter(function(f) {
        return (typeof f === 'string') && !!f;
      }).map(function(f) {
        return path.resolve(opts.basedir, f);
      }).filter(function(f) {
        var error, stat;
        try {
          stat = fs.statSync(f);
        } catch (error) {

        }
        switch (false) {
          case !(stat == null):
            return false;
          case !opts.isDirectory:
            return stat.isDirectory();
          case !opts.isFile:
            return stat.isFile();
          default:
            return false;
        }
      });
    };

    SearchPath.prototype.base = function(path) {
      if (path == null) {
        path = this.opts.basedir;
      }
      this.opts.basedir = path;
      return this;
    };

    SearchPath.prototype.include = function() {
      var ref;
      return this.unshift.apply(this, this.exists((ref = []).concat.apply(ref, arguments), {
        isDirectory: true
      }));
    };

    SearchPath.prototype.locate = function() {
      var files, ref, res;
      files = (ref = []).concat.apply(ref, arguments);
      res = [];
      this.forEach((function(_this) {
        return function(dir) {
          return res.push.apply(res, _this.exists(files.map(function(f) {
            return path.resolve(dir, f);
          }), {
            isFile: true
          }));
        };
      })(this));
      return res;
    };

    SearchPath.prototype.resolve = function() {
      var files, ref;
      files = ((ref = []).concat.apply(ref, arguments)).filter(function(x) {
        return (x != null) && !!x;
      }).reduce(((function(_this) {
        return function(a, b) {
          var ext, i, len, ref;
          a.push(b);
          if (!!!(path.extname(b))) {
            ref = _this.opts.exts;
            for (i = 0, len = ref.length; i < len; i++) {
              ext = ref[i];
              a.push(b + "." + ext);
            }
          }
          return a;
        };
      })(this)), []);
      return this.locate(files);
    };

    SearchPath.prototype.fetch = function() {
      var ref;
      return (this.resolve((ref = []).concat.apply(ref, arguments))).map(function(f) {
        return fs.readFileSync(f, this.opts.encoding);
      });
    };

    return SearchPath;

  })(Array);

  module.exports = SearchPath;

}).call(this);
